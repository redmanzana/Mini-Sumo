
#define pwma 3
#define aIn1 5
#define aIn2 4

#define pwmb 9
#define bIn1 7
#define bIn2 8

#define standBy 6

bool flow_a;
bool flow_b;


#define lineSensor_a 3
#define lineSensor_b 4
bool isLine_a = false;
bool isLine_b = false;

const uint8_t distanceSensorLeft = A0;
const uint8_t distanceSensorMiddle = A1;
const uint8_t distanceSensorRight = A3;
//preguntar si se puede #define :p


float outputReadLeft;
float distanceLeft;
float outputReadMiddle;
float distanceMiddle;
float outputReadMiddle;
float distanceMiddle;

const int RingDistance = 77;


void setup()
{
  // Motor a
  pinMode(pwma, OUTPUT);
  pinMode(aIn1, OUTPUT);
  pinMode(aIn2, OUTPUT);
  //Motor b
  pinMode(pwmb, OUTPUT);
  pinMode(bIn1, OUTPUT);
  pinMode(bIn2, OUTPUT);
  //Para indicar al puente h
  pinMode(standBy, OUTPUT);
  //Sensores de linea
  pinMode(lineSensor_a, OUTPUT);
  pinMode(lineSensor_a, OUTPUT);
  //Sensores de distancia
  pinMode(distanceSensorLeft, OUTPUT);
  pinMode(distanceSensorMiddle, OUTPUT);
  pinMode(distanceSensorRight, OUTPUT);
//checar si se puede hacer for(14-16) :p
}

void walk(int pwra, int pwrb)
{
  /* Condicionales para
    determinar direcciÃ³n de cada motor */

  waya = pwra >= 0;
  analogWrite(pwma, waya ? pwra : -pwra);
  digitalWrite(aIn1, waya ? HIGH : LOW);
  digitalWrite(aIn2, waya ? LOW : HIGH);

  wayb = pwrb >= 0;
  analogWrite(pwmb, wayb ? pwrb : -pwrb);
  digitalWrite(bIn1, wayb ? HIGH : LOW);
  digitalWrite(bIn1, wayb ? LOW : HIGH);

  digitalWrite(standBy, HIGH);
}

/* ~ Para leer sensor de linea ~
  eye = digitalRead(watcher);
*/

float tTravel()
{
  digitalWrite(shouter, HIGH);
  delayMicroseconds(10);
  digitalWrite(shouter, LOW);

  return pulseIn(listener, HIGH);
}




void DefenseMode(){

}

void SearchMode(){
  //creo isai tenia una parecida
}

void AttackMode(){
  if()
}

void DistanceCm(distanceSensor){
  OutputRead = analogRead(distanceSensor0)
  return 29.988 * pow(OutputRead, -1.173)
  //d internet, checar
}

void loop() {
  distanceLeft = DistanceCm(outputReadLeft);
  distanceMiddle = DistanceCm(outputReadMiddle);
  distanceRight = DistanceCm(outputReadRight);
  delay(50)

  if(Distance)
  //Run
  Walk()

}

{}
